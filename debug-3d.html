<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Debug - Wonderful World</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }
        
        button {
            margin: 5px;
            padding: 10px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background: #555;
        }
        
        #threejs-canvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="debug-info">
        <div>Status: <span id="status">Loading...</span></div>
        <div>Camera: <span id="camera-pos">N/A</span></div>
        <div>Model: <span id="model-info">N/A</span></div>
        <div>Scene Objects: <span id="scene-objects">0</span></div>
    </div>
    
    <div id="controls">
        <button onclick="resetCamera()">Reset Camera</button>
        <button onclick="toggleWireframe()">Toggle Wireframe</button>
        <button onclick="toggleLighting()">Toggle Lighting</button>
        <button onclick="logModelInfo()">Log Model Info</button>
    </div>
    
    <canvas id="threejs-canvas"></canvas>

    <script>
        let scene, camera, renderer, model, gltfLoader;
        let lights = [];
        let wireframeMode = false;
        let lightingEnabled = true;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            const canvas = document.getElementById('threejs-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            
            // Lighting
            setupLighting();
            
            // Add test objects
            addTestObjects();
            
            // Load GLB model
            loadModel();
            
            // Controls
            setupControls();
            
            // Start animation loop
            animate();
            
            document.getElementById('status').textContent = 'Initialized';
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 2.0);
            scene.add(ambientLight);
            lights.push(ambientLight);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 3.0);
            mainLight.position.set(20, 20, 20);
            mainLight.castShadow = true;
            scene.add(mainLight);
            lights.push(mainLight);
            
            // Point lights
            const pointLight1 = new THREE.PointLight(0x00ffff, 2.0, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);
            lights.push(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff4081, 1.5, 80);
            pointLight2.position.set(-10, 5, -10);
            scene.add(pointLight2);
            lights.push(pointLight2);
        }
        
        function addTestObjects() {
            // Test cube
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const cubeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            const testCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            testCube.position.set(-8, 0, 0);
            scene.add(testCube);
            
            // Test sphere
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0x220000
            });
            const testSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            testSphere.position.set(8, 0, 0);
            scene.add(testSphere);
            
            console.log('Test objects added');
        }
        
        function loadModel() {
            document.getElementById('status').textContent = 'Loading Model...';
            
            gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(
                './wonderful_world.glb',
                (gltf) => {
                    console.log('Model loaded:', gltf);
                    model = gltf.scene;
                    
                    // Center and scale the model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    model.position.sub(center);
                    
                    const maxDimension = Math.max(size.x, size.y, size.z);
                    const scale = 10 / maxDimension;
                    model.scale.setScalar(scale);
                    
                    // Enhance materials
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => enhanceMaterial(mat));
                                } else {
                                    enhanceMaterial(child.material);
                                }
                            }
                        }
                    });
                    
                    scene.add(model);
                    
                    document.getElementById('status').textContent = 'Model Loaded Successfully';
                    document.getElementById('model-info').textContent = 
                        `Size: ${size.x.toFixed(2)}x${size.y.toFixed(2)}x${size.z.toFixed(2)}, Scale: ${scale.toFixed(2)}`;
                    
                    console.log('Model added to scene. Position:', model.position);
                    console.log('Model size:', size);
                    console.log('Applied scale:', scale);
                },
                (progress) => {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    document.getElementById('status').textContent = `Loading: ${percent}%`;
                },
                (error) => {
                    console.error('Error loading model:', error);
                    document.getElementById('status').textContent = 'Model Load Failed';
                }
            );
        }
        
        function enhanceMaterial(material) {
            material.side = THREE.DoubleSide;
            
            if (material.emissive) {
                material.emissive.setHex(0x223344);
                material.emissiveIntensity = 0.3;
            }
            
            if (material.color) {
                material.color.multiplyScalar(1.5);
            }
            
            material.needsUpdate = true;
        }
        
        function setupControls() {
            // Mouse controls
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Update camera based on mouse
            function updateCamera() {
                const targetX = mouseX * 5;
                const targetY = mouseY * 5 + 5;
                
                camera.position.x += (targetX - camera.position.x) * 0.05;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
            }
            
            window.updateCamera = updateCamera;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update debug info
            document.getElementById('camera-pos').textContent = 
                `${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
            document.getElementById('scene-objects').textContent = scene.children.length;
            
            // Update camera
            if (window.updateCamera) window.updateCamera();
            
            // Rotate model
            if (model) {
                model.rotation.y += 0.005;
            }
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Control functions
        function resetCamera() {
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
        }
        
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            if (model) {
                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.wireframe = wireframeMode;
                                mat.needsUpdate = true;
                            });
                        } else {
                            child.material.wireframe = wireframeMode;
                            child.material.needsUpdate = true;
                        }
                    }
                });
            }
        }
        
        function toggleLighting() {
            lightingEnabled = !lightingEnabled;
            lights.forEach(light => {
                light.visible = lightingEnabled;
            });
        }
        
        function logModelInfo() {
            if (model) {
                console.log('=== MODEL DEBUG INFO ===');
                console.log('Position:', model.position);
                console.log('Scale:', model.scale);
                console.log('Rotation:', model.rotation);
                console.log('Visible:', model.visible);
                console.log('Children:', model.children.length);
                console.log('Scene children:', scene.children.length);
                
                model.traverse((child, index) => {
                    if (child.isMesh) {
                        console.log(`Mesh ${index}:`, child.name, child.geometry, child.material);
                    }
                });
            } else {
                console.log('No model loaded yet');
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        init();
    </script>
</body>
</html>
